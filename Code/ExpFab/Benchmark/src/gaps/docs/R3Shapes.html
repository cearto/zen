<HTML>
<HEAD>
<TITLE> R3Shapes Package </TITLE>
</HEAD>
<BODY>
<H1> R3Shapes Package </H1>



<HR><H2>Description:</H2>

The R3Shapes package supports basics 3D geometry classes.
<P>
It contains classes representing 3D primitives (such as vectors,
points, lines, rays, spans, planes, and halfspaces).  It also contains
classes for 3D transformations (such as 4x4 matrices, etc.) and higher
level 3D shapes (such as polygons, boxes, spheres, cones, pyramids,
prisms, etc).  The higher level shape classes are derived from an
abstract R3Shape class which supports transformations, bounding box
queries, drawing, and other abstract geometric functions.
<P>
For all pairs of 3D primitives (and many 3D shapes), functions are
provided for computing the relationships between them.  For instance,
there are functions to compute the distance between primitives
(R3Distance), check for intersections (R3Intersects), check whether
one primitive contains another (R3Contains), compute whether
primitives are perpendicular (R3Perpendicular), and check whether
primitives are parallel (R3Parallel).
<P>


<HR><H2>List of Classes:</H2>

<UL>
<LI> 3D Primitives:
<DL>
  <DT> <A HREF="#R3Vector">R3Vector</A> - 3D vector.
  <DT> <A HREF="#R3Point">R3Point</A> - 3D point.
  <DT> <A HREF="#R3Line">R3Line</A> - 3D infinite line.
  <DT> <A HREF="#R3Ray">R3Ray</A> - 3D ray.
  <DT> <A HREF="#R3Span">R3Span</A> - 3D line segment.
  <DT> <A HREF="#R3Plane">R3Plane</A> - 3D plane.
  <DT> <A HREF="#R3Halfspace">R3Halfspace</A> - 3D halfspace.
</DL>
<LI> 3D Shapes:
<DL>
  <DT> <A HREF="#R3Shape">R3Shape</A> - abstract 3D shape.
  <P>
  <DT> <A HREF="#R3Surface">R3Surface</A> - abstract 3D surface.
  <DT> <A HREF="#R3Circle">R3Circle</A> - 3D circle.
  <DT> <A HREF="#R3Ellipse">R3Ellipse</A> - 3D ellipse.
  <DT> <A HREF="#R3Triangle">R3Triangle</A> - 3D triangle.
  <DT> <A HREF="#R3Mesh">R3Mesh</A> - surface defined by a set of 3D triangles.
  <P>
  <DT> <A HREF="#R3Solid">R3Solid</A> - abstract 3D solid.
  <DT> <A HREF="#R3Box">R3Box</A> - 3D axis-aligned box. 
  <DT> <A HREF="#R3Cylinder">R3Cylinder</A> - 3D cylinder.
  <DT> <A HREF="#R3Cone">R3Cone</A> - 3D cone.
  <DT> <A HREF="#R3Sphere">R3Sphere</A> - 3D sphere.
  <DT> <A HREF="#R3Ellipsoid">R3Ellipsoid</A> - 3D axis-aligned ellipsoid.
  <P>
  <DT> <A HREF="#R3Grid">R3Grid</A> - 3D scalar grid.
</DL>
<LI> 3D Transformations:
<DL>
  <DT> <A HREF="#R3Transformation">R3Transformation</A> - abstract 3D transformation.
  <DT> <A HREF="#R3Affine">R3Affine</A> - 3D affine transformation.
  <P>
  <DT> <A HREF="#R3CoordSystem">R3CoordSystem</A> - 3D coordinate system (origin and triad).
  <DT> <A HREF="#R3Triad">R3Triad</A> - 3 orthogonal axis vectors.
  <DT> <A HREF="#R4Matrix">R4Matrix</A> - 4x4 matrix.
</DL>
</UL>
<P>



<HR><H2>List of Functions:</H2>

<UL>
<LI> 3D Relationships:
<DL>
  <DT> <A HREF="../pkgs/R3Shapes/R3Dist.h">R3Distance</A> - returns distance between two primitives.
  <DT> <A HREF="../pkgs/R3Shapes/R3Isect.h">R3Intersects</A> - returns whether two primitives intersect.
  <DT> <A HREF="../pkgs/R3Shapes/R3Cont.h">R3Contains</A> - returns whether one primitive contains another.
  <DT> <A HREF="../pkgs/R3Shapes/R3Cont.h">R3Inside</A> - returns whether one primitive is contained by another.
  <DT> <A HREF="../pkgs/R3Shapes/R3Parall.h">R3Parallel</A> - returns whether one primitive is parallel to another.
  <DT> <A HREF="../pkgs/R3Shapes/R3Perp.h">R3Perpendicular</A> - returns whether one primitive is perpendicular to another.
</DL>
</UL>
<P>



<HR><H2>Example:</H2>

Click <A HREF="../apps/r3shapes/r3shapes.C">this</A> to see a sample program.
<P>



<HR> <H2> <A NAME="R3Affine" HREF="../pkgs/R3Shapes/R3Affine.h">R3Affine</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Transformation">R3Transformation</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Affine(void);
<DT>	R3Affine(const R4Matrix& matrix, RNBoolean mirror = 0);
<DT>        virtual ~R3Affine(void);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>        const R4Matrix& Matrix(void) const;
<DT>        const R4Matrix& InverseMatrix(void) const;
<DT>        const RNBoolean IsIdentity(void) const;
<DT>        const RNBoolean IsMirrored(void) const;
<DT>        const RNBoolean IsAffine(void) const;
<DT>        const RNBoolean IsIsotropic(void) const;
<DT>        const RNBoolean HasTranslation(void) const;
<DT>        const RNBoolean HasScale(void) const;
<DT>        const RNBoolean HasRotation(void) const;
<DT>        const RNBoolean HasMirror(void) const;
<DT>	const R3Affine Inverse(void) const;
<DT>
</DL>
<DT> <H4> Application functions/operators: </H4>
<DL>
<DT>	void Apply(R3Vector& vector) const;
<DT>	void Apply(R3Point& point) const;
<DT>	void Apply(R3Transformation& transformation) const;
<DT>	void Apply(R3Affine& affine) const;
<DT>	void ApplyInverse(R3Vector& vector) const;
<DT>	void ApplyInverse(R3Point& point) const;
<DT>	void ApplyInverse(R3Transformation& transformation) const;
<DT>	void ApplyInverse(R3Affine& affine) const;
<DT>	void ApplyInverseTranspose(R3Vector& vector) const;
<DT>	void ApplyTranspose(R3Vector& vector) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        void Invert(void);
<DT>        void Mirror(void);
<DT>        void XMirror(void);
<DT>        void YMirror(void);
<DT>        void ZMirror(void);
<DT>        void Mirror(RNAxis axis);
<DT>        void Mirror(const R3Plane& plane);
<DT>	void XTranslate(RNScalar offset);
<DT>	void YTranslate(RNScalar offset);
<DT>	void ZTranslate(RNScalar offset);
<DT>	void Translate(RNScalar offset);
<DT>	void Translate(RNAxis axis, RNScalar offset);
<DT>	void Translate(const R3Vector& offset);
<DT>	void XScale(RNScalar scale);
<DT>	void YScale(RNScalar scale);
<DT>	void ZScale(RNScalar scale);
<DT>	void Scale(RNScalar scale);
<DT>	void Scale(RNAxis axis, RNScalar scale);
<DT>	void Scale(const R3Vector& scale);
<DT>	void XRotate(RNAngle radians);
<DT>	void YRotate(RNAngle radians);
<DT>	void ZRotate(RNAngle radians);
<DT>	void Rotate(const R3Vector& radians);
<DT>	void Rotate(RNAxis axis, RNAngle radians);
<DT>	void Rotate(const R3Vector& vector, RNAngle radians);
<DT>	void Rotate(const R3Vector& from, const R3Vector& to);
<DT>	void Transform(const R3Transformation& transformation);
<DT>	void Transform(const R3Affine& affine);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Affine& affine);
<DT>	void Reset(const R3Transformation& transformation);
<DT>	void Reset(const R4Matrix& matrix, RNBoolean mirror = 0);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Load(void) const;
<DT>        void Draw(void) const;
<DT>        void Push(void) const;
<DT>        void Pop(void) const;
<DT>
</DL>
<DT> <H4> Do not use these ???: </H4>
<DL>
<DT>        const RNScalar ScaleFactor(void) const;
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Base" HREF="../pkgs/R3Shapes/R3Base.h">R3Base</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Box" HREF="../pkgs/R3Shapes/R3Box.h">R3Box</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Solid">R3Solid</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Box(void);
<DT>        R3Box(const R3Box& box);
<DT>	R3Box(const R3Point& min, const R3Point& max);
<DT>	R3Box(RNCoord xmin, RNCoord ymin, RNCoord zmin, 
<DT>	      RNCoord xmax, RNCoord ymax, RNCoord zmax);
<DT>
</DL>
<DT> <H4> Box property functions/operators: </H4>
<DL>
<DT>	const RNCoord XMin(void) const;
<DT>	const RNCoord YMin(void) const;
<DT>	const RNCoord ZMin(void) const;
<DT>	const RNCoord XMax(void) const;
<DT>	const RNCoord YMax(void) const;
<DT>	const RNCoord ZMax(void) const;
<DT>	const RNCoord Coord(RNDirection dir, RNDimension dim) const;
<DT>	const R3Point& Min(void) const;
<DT>	const R3Point& Max(void) const;
<DT>	const R3Point Corner(RNOctant octant) const;
<DT>	const R3Point Corner(RNDirection xdir, RNDirection ydir, RNDirection zdir) const;
<DT>	const R3Point Centroid(void) const;
<DT>	const R3Point ClosestPoint(const R3Point& point) const;
<DT>	const R3Plane Plane(RNSide side) const;
<DT>	const R3Plane Plane(RNDirection dir, RNDimension dim) const;
<DT>	const R3Box Side(RNSide side) const;
<DT>	const R3Box Side(RNDirection dir, RNDimension dim) const;
<DT>	const R3Box Octant(RNOctant octant) const;
<DT>	const R3Box Octant(RNDirection xdir, RNDirection ydir, RNDirection zdir) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>        const int NDimensions(void) const;
<DT>        const int NDimensionsAlongSide(RNDirection dir, RNDimension dim) const;
<DT>	const RNBoolean IsSideNull(RNDirection dir, RNDimension dim) const;
<DT>	const RNBoolean IsSideLinear(RNDirection dir, RNDimension dim) const;	
<DT>        const int NDimensionsAlongAxis(const RNAxis axis) const;
<DT>	const RNBoolean IsAxisNull(const RNAxis axis) const;
<DT>	const RNLength XLength(void) const;
<DT>	const RNLength YLength(void) const;
<DT>	const RNLength ZLength(void) const;
<DT>	const RNLength AxisLength(const RNAxis axis) const;
<DT>	const RNLength DiagonalLength(void) const;
<DT>	const RNLength XRadius(void) const;
<DT>	const RNLength YRadius(void) const;
<DT>	const RNLength ZRadius(void) const;
<DT>	const RNLength AxisRadius(const RNAxis axis) const;
<DT>	const RNLength DiagonalRadius(void) const;
<DT>	const RNCoord XCenter(void) const;
<DT>	const RNCoord YCenter(void) const;
<DT>	const RNCoord ZCenter(void) const;
<DT>	const RNCoord AxisCenter(const RNAxis axis) const;
<DT>	const RNAxis ShortestAxis(void) const;
<DT>	const RNAxis LongestAxis(void) const;
<DT>	const RNLength ShortestAxisLength(void) const;
<DT>	const RNLength LongestAxisLength(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const RNVolume Volume(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        virtual void Empty(void);
<DT>        virtual void Inflate(RNScalar fraction);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>	virtual void Union(const R3Point& point);
<DT>	virtual void Union(const R3Box& box);
<DT>	virtual void Union(const R3Sphere& sphere);
<DT>	virtual void Intersect(const R3Box& box);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>	virtual void Reset(const R3Point& min, const R3Point& max);
<DT>	
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Box& box) const;
<DT>	RNBoolean operator!=(const R3Box& box) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Box);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Box);
<DT>
</DL>
<DT> <H4> Undocumented functions/operators: </H4>
<DL>
<DT>	const R3Point& operator[](RNDirection dir) const;
<DT>	R3Point& operator[](RNDirection dir);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Circle" HREF="../pkgs/R3Shapes/R3Circle.h">R3Circle</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Surface">R3Surface</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Circle(void);
<DT>        R3Circle(const R3Circle& circle);
<DT>        R3Circle(const R3Point& center, RNLength radius, const R3Vector& normal);
<DT>        R3Circle(const R3Point& p1, const R3Point& p2, const R3Point& p3);
<DT>
</DL>
<DT> <H4> Circle property functions/operators: </H4>
<DL>
<DT>        const R3Point& Center(void) const;
<DT>        const RNLength Radius(void) const;
<DT>	const R3Plane& Plane(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNLength Length(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Circle& circle) const;
<DT>	RNBoolean operator!=(const R3Circle& circle) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	virtual void Flip(void);
<DT>	virtual void Reposition(const R3Point& center);
<DT>	virtual void Translate(const R3Vector& offset);
<DT>	virtual void Align(const R3Vector& normal);
<DT>	virtual void Resize(RNScalar radius);
<DT>        virtual void Transform(const R3Transformation& transformation);
<DT>	virtual void Reset(const R3Point& center, RNScalar radius, const R3Vector& normal);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Circle);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Circle);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Cone" HREF="../pkgs/R3Shapes/R3Cone.h">R3Cone</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Solid">R3Solid</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Cone(void);
<DT>        R3Cone(const R3Cone& cone);
<DT>        R3Cone(const R3Span& axis, RNLength radius);
<DT>        R3Cone(const R3Point& p1, const R3Point& p2, RNLength radius);
<DT>
</DL>
<DT> <H4> Cone propetry functions/operators: </H4>
<DL>
<DT>        const R3Point& Apex(void) const;
<DT>        const R3Span& Axis(void) const;
<DT>        const R3Circle& Base(void) const;
<DT>        const RNLength Radius(void) const;
<DT>        const RNLength Height(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape propetry functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const ;
<DT>	virtual const RNBoolean IsPlanar(void) const ;
<DT>	virtual const RNBoolean IsConvex(void) const ;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const RNVolume Volume(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        virtual void Empty(void);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>        virtual void Reposition(const R3Span& span);
<DT>        virtual void Resize(RNLength radius);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Cone& cone) const;
<DT>	RNBoolean operator!=(const R3Cone& cone) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Cone);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Cone);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3CoordSystem" HREF="../pkgs/R3Shapes/R3CoordSystem.h">R3CoordSystem</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3CoordSystem(void);
<DT>	R3CoordSystem(const R3CoordSystem& cs);
<DT>	R3CoordSystem(const R3Point& origin, const R3Triad& axes);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const R3Point& Origin(void) const;
<DT>	const R3Triad& Axes(void) const;
<DT>        const R4Matrix Matrix(void) const;
<DT>        const R4Matrix InverseMatrix(void) const;
<DT>	const RNBoolean operator==(const R3CoordSystem& cs) const;
<DT>	const RNBoolean operator!=(const R3CoordSystem& cs) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Translate(const R3Vector& offset);
<DT>	void Rotate(RNAxis axis, RNAngle radians);
<DT>	void Rotate(const R3Vector& axis, RNAngle radians);
<DT>	void Rotate(const R3Vector& from, const R3Vector& to);
<DT>	void Mirror(const R3Plane& plane);
<DT>        void Transform(const R3Transformation& transformation);
<DT>        void InverseTransform(const R3Transformation& transformation);
<DT>        void SetOrigin(const R3Point& origin);
<DT>        void SetAxes(const R3Triad& axes);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>        void Outline(void) const;
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Curve" HREF="../pkgs/R3Shapes/R3Curve.h">R3Curve</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Shape">R3Shape</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors/destructors ???: </H4>
<DL>
<DT>	R3Curve(void);
<DT>	~R3Curve(void);
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	const RNBoolean IsCurve(void) const;
<DT>
</DL>
<DT> <H4> Curve property functions/operators: </H4>
<DL>
</DL>
<DT> <H4> virtual const R3Point StartPoint(void) const = 0;: </H4>
<DL>
</DL>
<DT> <H4> virtual const R3Point EndPoint(void) const = 0;: </H4>
<DL>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Cylinder" HREF="../pkgs/R3Shapes/R3Cylinder.h">R3Cylinder</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Solid">R3Solid</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Cylinder(void);
<DT>        R3Cylinder(const R3Cylinder& cylinder);
<DT>        R3Cylinder(const R3Span& axis, RNLength radius);
<DT>        R3Cylinder(const R3Point& p1, const R3Point& p2, RNLength radius);
<DT>
</DL>
<DT> <H4> Cylinder propetry functions/operators: </H4>
<DL>
<DT>        const R3Span& Axis(void) const;
<DT>        const R3Circle& Base(void) const;
<DT>        const R3Circle& Top(void) const;
<DT>        const RNLength Radius(void) const;
<DT>        const RNLength Height(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape propetry functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const ;
<DT>	virtual const RNBoolean IsPlanar(void) const ;
<DT>	virtual const RNBoolean IsConvex(void) const ;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const RNVolume Volume(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        virtual void Empty(void);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>        virtual void Reposition(const R3Span& span);
<DT>        virtual void Resize(RNLength radius);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Cylinder& cylinder) const;
<DT>	RNBoolean operator!=(const R3Cylinder& cylinder) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Cylinder);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Cylinder);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Ellipse" HREF="../pkgs/R3Shapes/R3Ellipse.h">R3Ellipse</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Surface">R3Surface</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Ellipse(void);
<DT>        R3Ellipse(const R3Ellipse& ellipse);
<DT>        R3Ellipse(const R3CoordSystem& cs, const R2Vector& radii);
<DT>
</DL>
<DT> <H4> Ellipse property functions/operators: </H4>
<DL>
<DT>        const R3Point& Center(void) const;
<DT>        const R2Vector& Radii(void) const;
<DT>	const R3Plane Plane(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	virtual void Flip(void);
<DT>        virtual void Empty(void);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>        virtual void Reposition(const R3Point& center);
<DT>        virtual void Resize(const R2Vector& radii);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Ellipse& ellipse) const;
<DT>	RNBoolean operator!=(const R3Ellipse& ellipse) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Ellipse);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Ellipse);
<DT>
</DL>
<DT> <H4> Upkeep functions: </H4>
<DL>
<DT>        void UpdateBBox(void);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Ellipsoid" HREF="../pkgs/R3Shapes/R3Ellipsoid.h">R3Ellipsoid</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Solid">R3Solid</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Ellipsoid(void);
<DT>        R3Ellipsoid(const R3Ellipsoid& ellipsoid);
<DT>        R3Ellipsoid(const R3CoordSystem& cs, const R3Vector& radii);
<DT>
</DL>
<DT> <H4> Ellipsoid property functions/operators: </H4>
<DL>
<DT>        const R3Point& Center(void) const;
<DT>        const R3CoordSystem& CoordSystem(void) const;
<DT>        const R3Vector& Radii(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const RNVolume Volume(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        virtual void Empty(void);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>        virtual void Reposition(const R3Point& center);
<DT>        virtual void Resize(const R3Vector& radii);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	RNBoolean operator==(const R3Ellipsoid& ellipsoid) const;
<DT>	RNBoolean operator!=(const R3Ellipsoid& ellipsoid) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Ellipsoid);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Ellipsoid);
<DT>
</DL>
<DT> <H4> Upkeep functions: </H4>
<DL>
<DT>        void UpdateBBox(void);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Grid" HREF="../pkgs/R3Shapes/R3Grid.h">R3Grid</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors: </H4>
<DL>
<DT>  R3Grid(int xresolution = 0, int yresolution = 0, int zresolution = 0);
<DT>  R3Grid(int xresolution, int yresolution, int zresolution, const R3Box& bbox);
<DT>  R3Grid(const R3Grid& grid);
<DT>  ~R3Grid(void);
<DT>
</DL>
<DT> <H4> Grid property functions: </H4>
<DL>
<DT>  int NEntries(void) const;
<DT>  int XResolution(void) const;
<DT>  int YResolution(void) const;
<DT>  int ZResolution(void) const;
<DT>  int Resolution(RNDimension dim) const;
<DT>  RNScalar Sum(void) const;
<DT>  RNScalar Mean(void) const;
<DT>  RNScalar Variance(void) const;
<DT>  RNScalar StandardDeviation(void) const;
<DT>  RNScalar Maximum(void) const;
<DT>  RNScalar Minimum(void) const;
<DT>  RNInterval Range(void) const;
<DT>  RNScalar L1Norm(void) const;
<DT>  RNScalar L2Norm(void) const;
<DT>  RNScalar L2NormSquared(void) const;
<DT>  RNScalar Volume(void) const;
<DT>  int Cardinality(void) const;
<DT>  R3Box GridBox(void) const;
<DT>  R3Box WorldBox(void) const;
<DT>  R3Point GridCentroid(void) const;
<DT>  R3Point WorldCentroid(void) const;
<DT>  R3Triad GridPrincipleAxes(const R3Point *grid_centroid = NULL, RNScalar *variances = NULL) const;
<DT>  R3Triad WorldPrincipleAxes(const R3Point *world_centroid = NULL, RNScalar *variances = NULL) const;
<DT>
</DL>
<DT> <H4> Transformation property functions: </H4>
<DL>
<DT>  const R3Affine& WorldToGridTransformation(void) const;
<DT>  const R3Affine& GridToWorldTransformation(void) const;
<DT>  RNScalar WorldToGridScaleFactor(void) const;
<DT>  RNScalar GridToWorldScaleFactor(void) const;
<DT>  RNScalar WorldSpacing(RNDimension dim) const;
<DT>
</DL>
<DT> <H4> Grid value access functions: </H4>
<DL>
<DT>  RNScalar GridValue(int index) const;
<DT>  RNScalar GridValue(int i, int j, int k) const;
<DT>  RNScalar GridValue(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  RNScalar GridValue(const R3Point& grid_point) const;
<DT>  RNScalar WorldValue(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  RNScalar WorldValue(const R3Point& world_point) const;
<DT>  RNScalar& operator()(int i, int j,int k);
<DT>
</DL>
<DT> <H4> Grid manipulation functions: </H4>
<DL>
<DT>  void Abs(void);
<DT>  void Sqrt(void);
<DT>  void Square(void);
<DT>  void Negate(void);
<DT>  void Invert(void);
<DT>  void Normalize(void);
<DT>  void DetectEdges(void);
<DT>  void Dilate(RNScalar grid_distance);
<DT>  void Erode(RNScalar grid_distance);
<DT>  void Blur(RNScalar grid_sigma = 2);
<DT>  void Clear(RNScalar value = 0);
<DT>  void Add(RNScalar value);
<DT>  void Copy(const R3Grid& grid);
<DT>  void Add(const R3Grid& grid);
<DT>  void Add(const R3Grid& grid, const R3Point& grid_position, const R3Point& filter_origin, RNScalar amplitude = 1);
<DT>  void Subtract(RNScalar value);
<DT>  void Subtract(const R3Grid& grid);
<DT>  void Multiply(RNScalar value);
<DT>  void Multiply(const R3Grid& grid);
<DT>  void Divide(RNScalar value);
<DT>  void Divide(const R3Grid& grid);
<DT>  void Pow(RNScalar exponent);
<DT>  void Mask(const R3Grid& grid);
<DT>  void Threshold(RNScalar threshold, RNScalar low, RNScalar high);
<DT>  void SquaredDistanceTransform(void);
<DT>  void Voronoi(R3Grid *squared_distance_grid = NULL);
<DT>  void Gauss(RNLength sigma = sqrt(8.0), RNBoolean square = TRUE);
<DT>  void Resample(int xres, int yres, int zres);
<DT>  void SetGridValue(int index, RNScalar value);
<DT>  void SetGridValue(int i, int j, int k, RNScalar value);
<DT>  void AddGridValue(int i, int j, int k, RNScalar value);
<DT>
</DL>
<DT> <H4> Arithmetic operators: </H4>
<DL>
<DT>  R3Grid& operator=(const R3Grid& grid);
<DT>  R3Grid& operator+=(RNScalar scale);
<DT>  R3Grid& operator+=(const R3Grid& grid);
<DT>  R3Grid& operator-=(RNScalar scale);
<DT>  R3Grid& operator-=(const R3Grid& grid);
<DT>  R3Grid& operator*=(RNScalar scale);
<DT>  R3Grid& operator*=(const R3Grid& grid);
<DT>  R3Grid& operator/=(RNScalar scale);
<DT>  R3Grid& operator/=(const R3Grid& grid);
<DT>
</DL>
<DT> <H4> Rasterization functions: </H4>
<DL>
<DT>  void RasterizeGridPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value);
<DT>  void RasterizeWorldPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value);
<DT>  void RasterizeGridPoint(const R3Point& point, RNScalar value);
<DT>  void RasterizeWorldPoint(const R3Point& point, RNScalar value);
<DT>  void RasterizeGridSpan(const int p1[3], const int p2[3], RNScalar value);
<DT>  void RasterizeGridSpan(const R3Point& p1, const R3Point& p2, RNScalar value);
<DT>  void RasterizeWorldSpan(const R3Point& p1, const R3Point& p2, RNScalar value);
<DT>  void RasterizeGridTriangle(const int p1[3], const int p2[3], const int p3[3], RNScalar value);
<DT>  void RasterizeGridTriangle(const R3Point& p1, const R3Point& p2, const R3Point& p3, RNScalar value);
<DT>  void RasterizeWorldTriangle(const R3Point& p1, const R3Point& p2, const R3Point& p3, RNScalar value);
<DT>  void RasterizeGridSphere(const R3Point& center, RNLength radius, RNScalar value, RNBoolean solid = TRUE);
<DT>  void RasterizeWorldSphere(const R3Point& center, RNLength radius, RNScalar value, RNBoolean solid = TRUE);
<DT>
</DL>
<DT> <H4> Relationship functions: </H4>
<DL>
<DT>  RNScalar Dot(const R3Grid& grid) const;
<DT>  RNScalar L1Distance(const R3Grid& grid) const;
<DT>  RNScalar L2Distance(const R3Grid& grid) const;
<DT>  RNScalar L2DistanceSquared(const R3Grid& grid) const;
<DT>
</DL>
<DT> <H4> Transformation manipulation functions: </H4>
<DL>
<DT>  void SetWorldToGridTransformation(const R3Affine& affine);
<DT>  void SetWorldToGridTransformation(const R3Box& world_box);
<DT>  void SetWorldToGridTransformation(const R3Point& world_origin, const R3Vector& world_axis1, const R3Vector& world_axis2, RNLength world_radius);
<DT>
</DL>
<DT> <H4> Transformation utility functions: </H4>
<DL>
<DT>  R3Point WorldPosition(const R3Point& grid_point) const;
<DT>  R3Point GridPosition(const R3Point& world_point) const;
<DT>  R3Point WorldPosition(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  R3Point GridPosition(RNCoord x, RNCoord y, RNCoord z) const;
<DT>
</DL>
<DT> <H4> I/O functions: </H4>
<DL>
<DT>  int ReadFile(const char *filename);
<DT>  int WriteFile(const char *filename) const;
<DT>  int ReadGridFile(const char *filename);
<DT>  int ReadDelphiFile(const char *filename);
<DT>  int ReadInsightFile(const char *filename);
<DT>  int ReadDXFile(const char *filename);
<DT>  int WriteGridFile(const char *filename) const;
<DT>  int ReadGrid(FILE *fp = NULL);
<DT>  int WriteGrid(FILE *fp = NULL) const;
<DT>  int Print(FILE *fp = NULL) const;
<DT>
</DL>
<DT> <H4> Visualization functions: </H4>
<DL>
<DT>  void DrawIsoSurface(RNScalar isolevel) const;
<DT>  void DrawSlice(int dim, int coord) const;
<DT>
</DL>
<DT> <H4> Utility functions: </H4>
<DL>
<DT>  int ConnectedComponents(RNScalar isolevel = 0, int max_components = 0, int *seeds = NULL, int *sizes = NULL, int *grid_components = NULL);
<DT>  int GenerateIsoSurface(RNScalar isolevel, R3Point *points, int max_points) const;
<DT>
</DL>
<DT> <H4> Debugging functions: </H4>
<DL>
<DT>  const RNScalar *GridValues(void) const;
<DT>  void IndicesToIndex(int i, int j, int k, int& index);
<DT>  void IndexToIndices(int index, int& i, int& j, int& k);
<DT>
</DL>
<DT> <H4> Gaussian filtering: </H4>
<DL>
<DT>  RNScalar GridValue(RNCoord x, RNCoord y, RNCoord z, RNLength sigma) const;
<DT>  RNScalar WorldValue(RNCoord x, RNCoord y, RNCoord z, RNLength sigma) const;
<DT>  void RasterizeGridPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value, RNLength sigma);
<DT>  void RasterizeWorldPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value, RNLength sigma);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Halfspace" HREF="../pkgs/R3Shapes/R3Halfspace.h">R3Halfspace</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Halfspace(void);
<DT>        R3Halfspace(const R3Halfspace& halfspace);
<DT>	R3Halfspace(RNScalar a, RNScalar b, RNScalar c, RNScalar d);
<DT>	R3Halfspace(const RNScalar array[4]);
<DT>	R3Halfspace(const R3Vector& normal, RNScalar d);
<DT>	R3Halfspace(const R3Point& point, const R3Vector& normal);
<DT>	R3Halfspace(const R3Point& point, const R3Line& line);
<DT>	R3Halfspace(const R3Point& point, const R3Vector& vector1, const R3Vector& vector2);
<DT>	R3Halfspace(const R3Point& point1, const R3Point& point2, const R3Point& point3);
<DT>	R3Halfspace(const R3Plane& plane, int dummy /* avoid implicit conversion */);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const R3Plane& Plane(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean operator==(const R3Halfspace& halfspace) const;
<DT>	const RNBoolean operator!=(const R3Halfspace& halfspace) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Mirror(const R3Plane& plane);
<DT>	void Translate(const R3Vector& vector);
<DT>	void Reposition(const R3Point& point);
<DT>	void Align(const R3Vector& vector);
<DT>        void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(const R3Plane& plane);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Halfspace operator-(void) const;
<DT>	
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Kdtree" HREF="../pkgs/R3Shapes/R3Kdtree.h">R3Kdtree</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor/destructors: </H4>
<DL>
<DT>  R3Kdtree(const R3Box& bbox, int position_offset = 0);
<DT>  R3Kdtree(const RNArray<PtrType>& points, int position_offset = 0);
<DT>  R3Kdtree(const RNArray<PtrType>& points, R3Point (*position_callback)(PtrType, void *), void *data);
<DT>  ~R3Kdtree(void);
<DT>
</DL>
<DT> <H4> Property functions: </H4>
<DL>
<DT>  const R3Box& BBox(void) const;
<DT>  int NNodes(void) const;
<DT>
</DL>
<DT> <H4> Search for closest to a point: </H4>
<DL>
<DT>  PtrType FindClosest(PtrType point, RNLength min_distance = 0, RNLength max_distance = RN_INFINITY, RNLength *closest_distance = NULL) const;
<DT>  PtrType FindClosest(const R3Point& position, RNLength min_distance = 0, RNLength max_distance = RN_INFINITY, RNLength *closest_distance = NULL) const;
<DT>
</DL>
<DT> <H4> Search for all within some distance to a point: </H4>
<DL>
<DT>  int FindAll(PtrType point, RNLength min_distance, RNLength max_distance, RNArray<PtrType>& points) const;
<DT>  int FindAll(const R3Point& position, RNLength min_distance, RNLength max_distance, RNArray<PtrType>& points) const;
<DT>
</DL>
<DT> <H4> Internal search functions: </H4>
<DL>
<DT>  void FindClosest(R3KdtreeNode<PtrType> *node, const R3Box& node_box, const R3Point& position, 
<DT>    RNLength min_distance_squared, RNLength max_distance_squared, 
<DT>    PtrType& closest_point, RNLength& closest_distance_squared) const;
<DT>  void FindAll(R3KdtreeNode<PtrType> *node, const R3Box& node_box, const R3Point& position, 
<DT>    RNLength min_distance_squared, RNLength max_distance_squared, RNArray<PtrType>& points) const;
<DT>
</DL>
<DT> <H4> Internal manipulation functions: </H4>
<DL>
<DT>  void InsertPoints(R3KdtreeNode<PtrType> *node, const R3Box& node_box, PtrType *points, int npoints);
<DT>  int PartitionPoints(PtrType *points, int npoints, RNDimension dim, int imin, int imax);
<DT>
</DL>
<DT> <H4> Internal visualization functions: </H4>
<DL>
<DT>  void Outline(R3KdtreeNode<PtrType> *node, const R3Box& bbox) const;
<DT>  void Outline(void) const;
<DT>
</DL>
<DT> <H4> Internal debugging functions: </H4>
<DL>
<DT>  void PrintDebugInfo(void) const;
<DT>  int PrintBalance(R3KdtreeNode<PtrType> *node, int depth) const;
<DT>
</DL>
<DT> <H4> Internal point extraction function: </H4>
<DL>
<DT>  const R3Point Position(PtrType point) const { 
<DT>    if (position_offset >= 0) return *((R3Point *) ((unsigned char *) point + position_offset)); 
<DT>    else if (position_callback) return (*position_callback)(point, position_callback_data);
<DT>    else { fprintf(stderr, "Invalid position callback\n"); abort(); return R3null_point; }
<DT>  } ;
<DT>
</DL>
<DT> <H4> Internal data: </H4>
<DL>
<DT>  R3Box bbox;
<DT>  int position_offset;
<DT>  R3Point (*position_callback)(PtrType, void *);
<DT>  void *position_callback_data;
<DT>  R3KdtreeNode<PtrType> *root;
<DT>  int nnodes;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Line" HREF="../pkgs/R3Shapes/R3Line.h">R3Line</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Line(void);
<DT>	R3Line(const R3Line& line);
<DT>	R3Line(const R3Point& point, const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>	R3Line(const R3Point& point1, const R3Point& point2);
<DT>	R3Line(RNCoord x1, RNCoord y1, RNCoord z1, RNCoord x2, RNCoord y2, RNCoord z2);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>        const R3Point& Point(void) const;
<DT>        const R3Vector& Vector(void) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean operator==(const R3Line& line) const;
<DT>	const RNBoolean operator!=(const R3Line& line) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Mirror(const R3Plane& plane);
<DT>        void Translate(const R3Vector& vector);
<DT>        void Reposition(const R3Point& point);
<DT>        void Align(const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>        void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(const R3Point& point, const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Line operator-(void) const;
<DT>	
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3MeshVertex" HREF="../pkgs/R3Shapes/R3MeshVertex.h">R3MeshVertex</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3MeshEdge" HREF="../pkgs/R3Shapes/R3MeshEdge.h">R3MeshEdge</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3MeshFace" HREF="../pkgs/R3Shapes/R3MeshFace.h">R3MeshFace</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
</DL> </DL>
</DL>



<P>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Mesh" HREF="../pkgs/R3Shapes/R3Mesh.h">R3Mesh</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> CONSTRUCTOR FUNCTIONS: </H4>
<DL>
<DT>    R3Mesh(void);
</DL>
<DT> <H4> Create an empty mesh: </H4>
<DL>
<DT>    virtual ~R3Mesh(void);
</DL>
<DT> <H4> Deallocate all data associated with mesh: </H4>
<DL>
<DT>
</DL>
<DT> <H4> VERTEX/EDGE/FACE ENUMERATION FUNCTIONS: </H4>
<DL>
<DT>    int NVertices(void) const;
</DL>
<DT> <H4> Return number of vertices in mesh: </H4>
<DL>
<DT>    R3MeshVertex *Vertex(int k) const;
</DL>
<DT> <H4> Return kth vertex of mesh: </H4>
<DL>
<DT>    int NEdges(void) const;
</DL>
<DT> <H4> Return number of edges in mesh: </H4>
<DL>
<DT>    R3MeshEdge *Edge(int k) const;
</DL>
<DT> <H4> Return kth edge of mesh: </H4>
<DL>
<DT>    int NFaces(void) const;
</DL>
<DT> <H4> Return number of faces in mesh: </H4>
<DL>
<DT>    R3MeshFace *Face(int k) const;
</DL>
<DT> <H4> Return kth face of mesh: </H4>
<DL>
<DT>
</DL>
<DT> <H4> MESH PROPERTIES: </H4>
<DL>
<DT>    const char *Name(void) const;
</DL>
<DT> <H4> Return name of mesh: </H4>
<DL>
<DT>    const R3Box& BBox(void) const;
</DL>
<DT> <H4> Return bounding box of all vertices in mesh: </H4>
<DL>
<DT>    R3Point Centroid(void) const;
</DL>
<DT> <H4> Return centroid of mesh: </H4>
<DL>
<DT>    RNLength AverageRadius(const R3Point *centroid = NULL) const;
</DL>
<DT> <H4> Return average distance from point on surface to centroid: </H4>
<DL>
<DT>    R3Triad PrincipleAxes(const R3Point *centroid = NULL, RNScalar *variances = NULL) const;
</DL>
<DT> <H4> Return principle axes of mesh: </H4>
<DL>
<DT>    R3Affine PCANormalizationTransformation(RNBoolean translate, RNBoolean rotate, RNBoolean scale) const;
</DL>
<DT> <H4> Return transformation that aligns centroid, principal axes, and scale with R3xyz_triad: </H4>
<DL>
<DT>
</DL>
<DT> <H4> VERTEX PROPERTIES: </H4>
<DL>
<DT>    const R3Point& VertexPosition(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the position of the vertex: </H4>
<DL>
<DT>    const R3Vector& VertexNormal(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the normal of the vertex: </H4>
<DL>
<DT>    int VertexValence(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the number of edges attached to vertex: </H4>
<DL>
<DT>    int VertexID(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the ID stored with a vertex: </H4>
<DL>
<DT>    RNFlags VertexFlags(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the flags stored with a vertex: </H4>
<DL>
<DT>    RNScalar VertexValue(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the value stored with a vertex: </H4>
<DL>
<DT>    RNMark VertexMark(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the mark stored with a vertex: </H4>
<DL>
<DT>    void *VertexData(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the user data stored with a vertex: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> EDGE PROPERTIES: </H4>
<DL>
<DT>    RNLength EdgeLength(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the length of the edge: </H4>
<DL>
<DT>    R3Point EdgeMidpoint(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the midpoint of the edge: </H4>
<DL>
<DT>    RNAngle EdgeInteriorAngle(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns interior angle between adjacent faces in range 0 to 2*PI (returns 0 if boundary edge): </H4>
<DL>
<DT>    RNScalar EdgeAspect(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns ratio of "distance between vertices across faces" over edge length: </H4>
<DL>
<DT>    R3Vector EdgeVector(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns a vector along the edge (v2 - v1): </H4>
<DL>
<DT>    R3Vector EdgeDirection(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns a normalized vector along edge (v2 - v1)/||v2 - v1||: </H4>
<DL>
<DT>    R3Span EdgeSpan(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the span covering the edge: </H4>
<DL>
<DT>    R3Line EdgeLine(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the line supporting the edge: </H4>
<DL>
<DT>    R3Box EdgeBBox(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the bounding box of the edge: </H4>
<DL>
<DT>    int EdgeID(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the ID stored with a edge: </H4>
<DL>
<DT>    RNFlags EdgeFlags(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the flags stored with the edge: </H4>
<DL>
<DT>    RNScalar EdgeValue(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the value stored with a edge: </H4>
<DL>
<DT>    RNMark EdgeMark(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the mark stored with the edge: </H4>
<DL>
<DT>    void *EdgeData(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the user data stored with the edge: </H4>
<DL>
<DT>
</DL>
<DT> <H4> FACE PROPERTIES: </H4>
<DL>
<DT>    const R3Vector& FaceNormal(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the normal of the face: </H4>
<DL>
<DT>    const R3Plane& FacePlane(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the plane equation of the face: </H4>
<DL>
<DT>    R3Point FaceCentroid(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the centroid of the face: </H4>
<DL>
<DT>    R3Point FacePoint(const R3MeshFace *face, RNMagnitude barycentrics[3]) const;
</DL>
<DT> <H4> Returns the point on the face with the given barycentric coordinates: </H4>
<DL>
<DT>    R3Point FaceBarycentric(const R3MeshFace *face, const R3Point& point) const;
</DL>
<DT> <H4> Returns the barycentric coordinates of point on face: </H4>
<DL>
<DT>    const R3Box& FaceBBox(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the bounding box of the face: </H4>
<DL>
<DT>    RNArea FaceArea(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the area of the face: </H4>
<DL>
<DT>    int FaceMaterial(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the material ID associated with a face: </H4>
<DL>
<DT>    int FaceSegment(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the segment ID associated with a face: </H4>
<DL>
<DT>    int FaceID(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the ID stored with a face: </H4>
<DL>
<DT>    RNFlags FaceFlags(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the flags stored with a face: </H4>
<DL>
<DT>    RNScalar FaceValue(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the value stored with a face: </H4>
<DL>
<DT>    RNMark FaceMark(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the mark stored with a face: </H4>
<DL>
<DT>    void *FaceData(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns the user data stored with a face: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> MANIPULATION FUNCTIONS: </H4>
<DL>
<DT>    void Empty(void);
</DL>
<DT> <H4> Delete all vertices, edges, faces: </H4>
<DL>
<DT>    void Transform(const R3Transformation& transformation);
</DL>
<DT> <H4> Transform mesh: </H4>
<DL>
<DT>    void SetName(const char *name);
</DL>
<DT> <H4> Set mesh name: </H4>
<DL>
<DT>
</DL>
<DT> <H4> VERTEX MANIPULATION FUNCTIONS: </H4>
<DL>
<DT>    void SetVertexPosition(R3MeshVertex *vertex, const R3Point& position);
</DL>
<DT> <H4> Set new position for vertex: </H4>
<DL>
<DT>    void SetVertexNormal(R3MeshVertex *vertex, const R3Vector& normal);
</DL>
<DT> <H4> Set new normal for vertex: </H4>
<DL>
<DT>    void SetVertexValue(R3MeshVertex *vertex, RNScalar value);
</DL>
<DT> <H4> Set the value stored with a vertex: </H4>
<DL>
<DT>    void SetVertexMark(R3MeshVertex *vertex, RNMark mark);
</DL>
<DT> <H4> Set the mark stored with a vertex: </H4>
<DL>
<DT>    void SetVertexData(R3MeshVertex *vertex, void *data);
</DL>
<DT> <H4> Set the data stored with a vertex: </H4>
<DL>
<DT>    void SetVertexFlags(R3MeshVertex *vertex, RNFlags flags);
</DL>
<DT> <H4> Set the flags stored with a vertex: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> EDGE MANIPULATION FUNCTIONS: </H4>
<DL>
<DT>    void SetEdgeMark(R3MeshEdge *edge, RNMark mark);
</DL>
<DT> <H4> Set the mark stored with a edge: </H4>
<DL>
<DT>    void SetEdgeValue(R3MeshEdge *edge, RNScalar value);
</DL>
<DT> <H4> Set the value stored with a edge: </H4>
<DL>
<DT>    void SetEdgeData(R3MeshEdge *edge, void *data);
</DL>
<DT> <H4> Set the data stored with a edge: </H4>
<DL>
<DT>    void SetEdgeFlags(R3MeshEdge *edge, RNFlags flags);
</DL>
<DT> <H4> Set the flags stored with a edge: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> FACE MANIPULATION FUNCTIONS: </H4>
<DL>
<DT>    void SetFacePlane(R3MeshFace *face, const R3Plane& plane);
</DL>
<DT> <H4> Set the plane equation for a face: </H4>
<DL>
<DT>    void SetFaceMaterial(R3MeshFace *face, int material);
</DL>
<DT> <H4> Set the material associated with a face: </H4>
<DL>
<DT>    void SetFaceSegment(R3MeshFace *face, int segment);
</DL>
<DT> <H4> Set the segment associated with a face: </H4>
<DL>
<DT>    void SetFaceMark(R3MeshFace *face, RNMark mark);
</DL>
<DT> <H4> Set the mark stored with a face: </H4>
<DL>
<DT>    void SetFaceValue(R3MeshFace *face, RNScalar value);
</DL>
<DT> <H4> Set the value stored with a face: </H4>
<DL>
<DT>    void SetFaceData(R3MeshFace *face, void *data);
</DL>
<DT> <H4> Set the data stored with a face: </H4>
<DL>
<DT>    void SetFaceFlags(R3MeshFace *face, RNFlags flags);
</DL>
<DT> <H4> Set the flags stored with a face: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> VERTEX TRAVERSAL FUNCTIONS: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnVertex(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns any edge connected to vertex: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnVertex(const R3MeshVertex *vertex, int k) const;
</DL>
<DT> <H4> Returns kth edge connected to vertex (edges are not sorted!): </H4>
<DL>
<DT>    R3MeshEdge *EdgeBetweenVertices(const R3MeshVertex *vertex1, const R3MeshVertex *vertex2) const;
</DL>
<DT> <H4> Returns edge spanning between two vertices (or NULL if none): </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnVertex(const R3MeshVertex *vertex, const R3MeshEdge *edge, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns edge on vertex in dir with respect to edge: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnVertex(const R3MeshVertex *vertex, const R3MeshFace *face, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns edge on vertex in dir with respect to face: </H4>
<DL>
<DT>    R3MeshEdge *EdgeAcrossVertex(const R3MeshVertex *vertex, const R3MeshEdge *edge, const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns edge on the other side of a vertex from an edge on the same face: </H4>
<DL>
<DT>    R3MeshFace *FaceOnVertex(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns any face connected to vertex: </H4>
<DL>
<DT>    R3MeshFace *FaceBetweenVertices(const R3MeshVertex *vertex1, const R3MeshVertex *vertex2, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns face between two vertices (in dir with respect to v1) or NULL if there is none: </H4>
<DL>
<DT>    R3MeshFace *FaceOnVertex(const R3MeshVertex *vertex, const R3MeshEdge *edge, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns face on vertex in dir with respect to edge: </H4>
<DL>
<DT>    R3MeshFace *FaceOnVertex(const R3MeshVertex *vertex, const R3MeshFace *face, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns face on vertex in dir with respect to face: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> EDGE TRAVERSAL FUNCTIONS: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnEdge(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns any vertex on edge: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnEdge(const R3MeshEdge *edge, int k) const;
</DL>
<DT> <H4> Returns kth vertex on edge: </H4>
<DL>
<DT>    R3MeshVertex *VertexAcrossEdge(const R3MeshEdge *edge, const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns vertex across edge: </H4>
<DL>
<DT>    R3MeshVertex *VertexBetweenEdges(const R3MeshEdge *edge1, const R3MeshEdge *edge2) const;
</DL>
<DT> <H4> Returns vertex between two edges (or NULL if there is none): </H4>
<DL>
<DT>    R3MeshVertex *VertexOnEdge(const R3MeshEdge *edge, const R3MeshFace *face, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns vertex of edge in dir with respect to face: </H4>
<DL>
<DT>    R3MeshFace *FaceOnEdge(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns any face on edge: </H4>
<DL>
<DT>    R3MeshFace *FaceOnEdge(const R3MeshEdge *edge, int k) const;
</DL>
<DT> <H4> Returns kth face on edge: </H4>
<DL>
<DT>    R3MeshFace *FaceOnEdge(const R3MeshEdge *edge, const R3MeshVertex *vertex, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns face on edge in dir with respect to vertex: </H4>
<DL>
<DT>    R3MeshFace *FaceBetweenEdges(const R3MeshEdge *edge1, const R3MeshEdge *edge2) const;
</DL>
<DT> <H4> Returns the face between two edges (or NULL if there is none): </H4>
<DL>
<DT>    R3MeshFace *FaceAcrossEdge(const R3MeshEdge *edge, const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns face across edge: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> FACE TRAVERSAL FUNCTIONS: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnFace(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns any vertex on face: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnFace(const R3MeshFace *face, int k) const;
</DL>
<DT> <H4> Returns kth vertex on face: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnFace(const R3MeshFace *face, const R3MeshVertex *vertex, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns vertex on face in dir with respect to vertex: </H4>
<DL>
<DT>    R3MeshVertex *VertexOnFace(const R3MeshFace *face, const R3MeshEdge *edge, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns vertex on face in dir with respect to edge: </H4>
<DL>
<DT>    R3MeshVertex *VertexAcrossFace(const R3MeshFace *face, const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns the vertex across a triangle from an edge (the edge is the base and the vertex is the apex): </H4>
<DL>
<DT>    R3MeshVertex *VertexBetweenFaces(const R3MeshFace *face1, const R3MeshFace *face2, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns the vertex between two faces (in dir with respect to face1) or NULL if there is none: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnFace(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns any edge connected to face: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnFace(const R3MeshFace *face, int k) const;
</DL>
<DT> <H4> Returns kth edge connected to face: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnFace(const R3MeshFace *face, const R3MeshVertex *vertex, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Returns edge on face in dir with respect to vertex: </H4>
<DL>
<DT>    R3MeshEdge *EdgeOnFace(const R3MeshFace *face, const R3MeshEdge *edge, RNDirection dir = RN_CCW) const;
</DL>
<DT> <H4> Return edge on face in dir with respect to edge: </H4>
<DL>
<DT>    R3MeshEdge *EdgeAcrossFace(const R3MeshFace *face, const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns the edge across a triangle from a vertex (the edge is the base and the vertex is the apex): </H4>
<DL>
<DT>    R3MeshEdge *EdgeBetweenFaces(const R3MeshFace *face1, const R3MeshFace *face2) const;
</DL>
<DT> <H4> Returns the edge between two faces (or NULL if there is none): </H4>
<DL>
<DT>    R3MeshFace *FaceOnFace(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns any face connected to face: </H4>
<DL>
<DT>    R3MeshFace *FaceOnFace(const R3MeshFace *face, int k) const;
</DL>
<DT> <H4> Returns kth face connected to face: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> TOPOLOGY QUERY FUNCTIONS: </H4>
<DL>
<DT>    RNBoolean IsVertexOnEdge(const R3MeshVertex *vertex, const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns whether vertex lies on edge: </H4>
<DL>
<DT>    RNBoolean IsVertexOnFace(const R3MeshVertex *vertex, const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns whether vertex lies on face: </H4>
<DL>
<DT>    RNBoolean IsEdgeOnFace(const R3MeshEdge *edge, const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns whether edge lies on face: </H4>
<DL>
<DT>    RNBoolean IsVertexOnMesh(const R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns whether vertex is part of mesh: </H4>
<DL>
<DT>    RNBoolean IsEdgeOnMesh(const R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns whether edge is part of mesh: </H4>
<DL>
<DT>    RNBoolean IsFaceOnMesh(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns whether face is part of mesh: </H4>
<DL>
<DT>    void FindConnectedFaces(R3MeshFace *seed, RNArray<R3MeshFace *>& faces);
</DL>
<DT> <H4> Fill array with faces in same connected component as seed: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> TOPOLOGY MANIPULATION FUNCTIONS: </H4>
<DL>
<DT>    virtual R3MeshVertex *CreateVertex(const R3Point& position, R3MeshVertex *vertex = NULL);
</DL>
<DT> <H4> Create a new vertex at a position (compute normal): </H4>
<DL>
<DT>    virtual R3MeshVertex *CreateVertex(const R3Point& position, const R3Vector& normal, R3MeshVertex *vertex = NULL);
</DL>
<DT> <H4> Create a new vertex at a position with a given normal: </H4>
<DL>
<DT>    virtual R3MeshEdge *CreateEdge(R3MeshVertex *v1, R3MeshVertex *v2, R3MeshEdge *edge = NULL);
</DL>
<DT> <H4> Create a new edge between two vertices: </H4>
<DL>
<DT>    virtual R3MeshFace *CreateFace(R3MeshVertex *v1, R3MeshVertex *v2, R3MeshVertex *v3, R3MeshFace *face = NULL);
</DL>
<DT> <H4> Create a face with vertices (v1, v2, v3): </H4>
<DL>
<DT>    virtual R3MeshFace *CreateFace(R3MeshEdge *e1, R3MeshEdge *e2, R3MeshEdge *e3, R3MeshFace *face = NULL);
</DL>
<DT> <H4> Create a face with edges (e1, e2, e3): </H4>
<DL>
<DT>    virtual R3MeshFace *CreateFace(R3MeshVertex *v1, R3MeshVertex *v2, R3MeshVertex *v3, 
<DT>                                   R3MeshEdge *e1, R3MeshEdge *e2, R3MeshEdge *e3, R3MeshFace *face = NULL);
</DL>
<DT> <H4> Create a face with vertices (v1, v2, v3) and edges (e1, e2, e3): </H4>
<DL>
<DT>    virtual void DeleteVertex(R3MeshVertex *v);
</DL>
<DT> <H4> Delete a vertex and all edges/faces attached to it: </H4>
<DL>
<DT>    virtual void DeleteEdge(R3MeshEdge *e);
</DL>
<DT> <H4> Delete an edge (attached vertices are unaffected, attached faces are deleted): </H4>
<DL>
<DT>    virtual void DeleteFace(R3MeshFace *f);
</DL>
<DT> <H4> Delete a face (attached vertices and edges are unaffected): </H4>
<DL>
<DT>    virtual R3MeshVertex *MergeVertex(R3MeshVertex *v1, R3MeshVertex *v2);
</DL>
<DT> <H4> Merge vertex v2 into vertex v1 (v2 is deleted): </H4>
<DL>
<DT>    virtual void MergeCoincidentVertices(RNLength epsilon = -1.0);
</DL>
<DT> <H4> Merge all vertices within epsilon of each other (negative epsilon says "select epsilon automatically"): </H4>
<DL>
<DT>    virtual R3MeshVertex *CollapseEdge(R3MeshEdge *edge, const R3Point& point);
</DL>
<DT> <H4> Collapses an edge into a vertex at point: </H4>
<DL>
<DT>    virtual R3MeshVertex *CollapseFace(R3MeshFace *face, const R3Point& point);
</DL>
<DT> <H4> Collapses a face into a vertex at point: </H4>
<DL>
<DT>    virtual R3MeshVertex *CollapseEdge(R3MeshEdge *edge);
</DL>
<DT> <H4> Collapses an edge into a vertex at point: </H4>
<DL>
<DT>    virtual R3MeshVertex *CollapseFace(R3MeshFace *face);
</DL>
<DT> <H4> Collapses a face into a vertex at point: </H4>
<DL>
<DT>    virtual R3MeshVertex *SplitEdge(R3MeshEdge *edge, const R3Point& point, R3MeshEdge **e0 = NULL, R3MeshEdge **e1 = NULL);
</DL>
<DT> <H4> Creates a vertex at point, and inserts it into an edge, returns new vertex and edges (in e0-e1): </H4>
<DL>
<DT>    virtual R3MeshVertex *SplitEdge(R3MeshEdge *edge, const R3Plane& plane);
</DL>
<DT> <H4> Creates a vertex at intersection with plane, and inserts it into an edge: </H4>
<DL>
<DT>    virtual R3MeshVertex *SubdivideEdge(R3MeshEdge *edge);
</DL>
<DT> <H4> Splits edge at midpoint: </H4>
<DL>
<DT>    virtual int SwapEdge(R3MeshEdge *edge);
</DL>
<DT> <H4> Swap edge to use vertices across from adjacent faces: </H4>
<DL>
<DT>    virtual void FlipEdge(R3MeshEdge *edge);
</DL>
<DT> <H4> Reverse direction of edge (not important for most applications): </H4>
<DL>
<DT>    virtual void FlipFace(R3MeshFace *face);
</DL>
<DT> <H4> Reverses orientation of face: </H4>
<DL>
<DT>    virtual R3MeshVertex *SplitFace(R3MeshFace *face, const R3Point& point, 
<DT>      R3MeshFace **f0 = NULL, R3MeshFace **f1 = NULL, R3MeshFace **f2 = NULL);
</DL>
<DT> <H4> Creates a new vertex at point, removes face, and builds new faces between edges and new vertices, returns new vertex and faces (in f0-f2): </H4>
<DL>
<DT>    virtual R3MeshFace *SubdivideFace(R3MeshFace *face);
</DL>
<DT> <H4> Splits face into four by subdividing each edge at midpoint (returns middle face): </H4>
<DL>
<DT>
</DL>
<DT> <H4> DRAW FUNCTIONS: </H4>
<DL>
<DT>    virtual void Draw(void) const;
</DL>
<DT> <H4> Draws the faces: </H4>
<DL>
<DT>    virtual void DrawVertices(void) const;
</DL>
<DT> <H4> Draws the vertices: </H4>
<DL>
<DT>    virtual void DrawEdges(void) const;
</DL>
<DT> <H4> Draws the edges: </H4>
<DL>
<DT>    virtual void DrawFaces(void) const;
</DL>
<DT> <H4> Draws the faces: </H4>
<DL>
<DT>    virtual void DrawVertexIDs(void) const;
</DL>
<DT> <H4> Draws the vertex IDs into color buffer: </H4>
<DL>
<DT>    virtual void DrawEdgeIDs(void) const;
</DL>
<DT> <H4> Draws the edge IDs into color buffer: </H4>
<DL>
<DT>    virtual void DrawFaceIDs(void) const;
</DL>
<DT> <H4> Draws the face IDs into color buffer: </H4>
<DL>
<DT>    virtual void DrawVertex(R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Draws one vertex: </H4>
<DL>
<DT>    virtual void DrawEdge(R3MeshEdge *edge) const;
</DL>
<DT> <H4> Draws one edge: </H4>
<DL>
<DT>    virtual void DrawFace(R3MeshFace *face) const;
</DL>
<DT> <H4> Draws one face: </H4>
<DL>
<DT>
</DL>
<DT> <H4> INTERSECT FUNCTIONS: </H4>
<DL>
<DT>    R3MeshType Intersection(const R3Ray& ray, R3MeshIntersection *intersection = NULL) const;
</DL>
<DT> <H4> Returns first intersection along ray: </H4>
<DL>
<DT>    R3MeshType Intersection(const R3Ray& ray, R3MeshFace *face, R3MeshIntersection *intersection = NULL) const;
</DL>
<DT> <H4> Returns intersection with face along ray: </H4>
<DL>
<DT>  
</DL>
<DT> <H4> GEOMETRIC QUERY FUNCTIONS: </H4>
<DL>
<DT>    R3Point ClosestPointOnEdge(const R3MeshEdge *edge, const R3Point& point) const;
</DL>
<DT> <H4> Returns closest point on edge: </H4>
<DL>
<DT>    R3Point ClosestPointOnFace(const R3MeshFace *face, const R3Point& point) const;
</DL>
<DT> <H4> Returns closest point on face: </H4>
<DL>
<DT>    R3Point RandomPointOnFace(const R3MeshFace *face) const;
</DL>
<DT> <H4> Returns random point on face: </H4>
<DL>
<DT>
</DL>
<DT> <H4> I/O FUNCTIONS: </H4>
<DL>
<DT>    int ReadFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from a file, returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadObjFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from Wavefront file (.obj), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadOffFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from OFF (.off) file, returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadRayFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from ray file (.ray), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadPlyFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from ply file (.ply), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadCattFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from a Catt acoustic file (.cat), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadIfsFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from ifs file (.ifs), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadSTLFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from STL file (.stl), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int ReadVRMLFile(const char *filename);
</DL>
<DT> <H4> Loads data structure from VRML file (.wrl), returns number of faces created (0 is error): </H4>
<DL>
<DT>    int WriteFile(const char *filename);
</DL>
<DT> <H4> Writes a file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteRayFile(const char *filename);
</DL>
<DT> <H4> Writes a ray file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WritePlyFile(const char *filename);
</DL>
<DT> <H4> Writes a PLY file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteObjFile(const char *filename);
</DL>
<DT> <H4> Writes a Wavefront OBJ file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteOffFile(const char *filename);
</DL>
<DT> <H4> Writes a OFF (.off) file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteCattFile(const char *filename);
</DL>
<DT> <H4> Writes a Catt Acoustics (.cat) file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteIfsFile(const char *filename);
</DL>
<DT> <H4> Writes a IFS (.ifs) file, returns number of faces written (0 is error): </H4>
<DL>
<DT>    int WriteSTLFile(const char *filename);
</DL>
<DT> <H4> Writes a STL (.stl) file, returns number of faces written (0 is error): </H4>
<DL>
<DT>
</DL>
<DT> <H4> DEBUG FUNCTIONS: </H4>
<DL>
<DT>    virtual RNBoolean IsValid(void) const;
</DL>
<DT> <H4> Returns whether data structure is valid: </H4>
<DL>
<DT>    virtual RNBoolean IsValid(R3MeshVertex *vertex) const;
</DL>
<DT> <H4> Returns whether vertex data structure is valid: </H4>
<DL>
<DT>    virtual RNBoolean IsValid(R3MeshEdge *edge) const;
</DL>
<DT> <H4> Returns whether edge data structure is valid: </H4>
<DL>
<DT>    virtual RNBoolean IsValid(R3MeshFace *face) const;
</DL>
<DT> <H4> Returns whether face data structure is valid: </H4>
<DL>
<DT>  
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3MeshSearchTree" HREF="../pkgs/R3Shapes/R3MeshSearchTree.h">R3MeshSearchTree</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor/destructors: </H4>
<DL>
<DT>  R3MeshSearchTree(R3Mesh *mesh);
<DT>  ~R3MeshSearchTree(void);
<DT>
</DL>
<DT> <H4> Property functions: </H4>
<DL>
<DT>  const R3Box& BBox(void) const;
<DT>
</DL>
<DT> <H4> Insert/delete functions: </H4>
<DL>
<DT>  void InsertFace(R3MeshFace *face);
<DT>  void Empty(void);
<DT>
</DL>
<DT> <H4> Find mesh feature closest to a query point: </H4>
<DL>
<DT>  void FindClosest(const R3Point& query, R3MeshIntersection& closest,
<DT>    RNScalar min_distance = 0, RNScalar max_distance = RN_INFINITY,
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *) = NULL, 
<DT>    void *compatible_data = NULL);
<DT>
</DL>
<DT> <H4> Find mesh feature closest to a query point and normal: </H4>
<DL>
<DT>  void FindClosest(const R3Point& query, const R3Vector& normal, R3MeshIntersection& closest,
<DT>    RNScalar min_distance = 0, RNScalar max_distance = RN_INFINITY, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *) = NULL, 
<DT>    void *compatible_data = NULL);
<DT>
</DL>
<DT> <H4> Find all mesh features with distance from a query point: </H4>
<DL>
<DT>  void FindAll(const R3Point& query, RNArray<R3MeshIntersection *>& hits,
<DT>    RNScalar min_distance = 0, RNScalar max_distance = RN_INFINITY,
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *) = NULL, 
<DT>    void *compatible_data = NULL);
<DT>
</DL>
<DT> <H4> Find all mesh features with distance from a query point and normal: </H4>
<DL>
<DT>  void FindAll(const R3Point& query, const R3Vector& normal, RNArray<R3MeshIntersection *>& hits,
<DT>    RNScalar min_distance = 0, RNScalar max_distance = RN_INFINITY, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *) = NULL, 
<DT>    void *compatible_data = NULL);
<DT>
</DL>
<DT> <H4> Visualization/debugging functions: </H4>
<DL>
<DT>  int NNodes(void) const;
<DT>  void Outline(void) const;
<DT>  void Print(void) const;
<DT>
</DL>
<DT> <H4> Internal manipulations functions: </H4>
<DL>
<DT>  void Empty(R3MeshSearchTreeNode *node);
<DT>
</DL>
<DT> <H4> Internal insert functions: </H4>
<DL>
<DT>  void InsertFace(R3MeshSearchTreeFace *face, R3MeshSearchTreeNode *node, const R3Box& node_box, int depth);
<DT>
</DL>
<DT> <H4> Internal closest point search functions: </H4>
<DL>
<DT>  void FindClosest(const R3Point& query, const R3Vector& normal, R3MeshIntersection& closest, 
<DT>    RNScalar min_distance_squared, RNScalar& max_distance_squared, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *), void *compatible_data,
<DT>    R3MeshSearchTreeNode *node, const R3Box& node_box) const;
<DT>  void FindClosest(const R3Point& query, const R3Vector& normal, R3MeshIntersection& closest, 
<DT>    RNScalar min_distance_squared, RNScalar& max_distance_squared, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *), void *compatible_data,
<DT>    R3MeshFace *face) const;
<DT>
</DL>
<DT> <H4> Internal all point search functions: </H4>
<DL>
<DT>  void FindAll(const R3Point& query, const R3Vector& normal, RNArray<R3MeshIntersection *>& hits,
<DT>    RNScalar min_distance_squared, RNScalar max_distance_squared, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *), void *compatible_data,
<DT>    R3MeshSearchTreeNode *node, const R3Box& node_box) const;
<DT>  void FindAll(const R3Point& query, const R3Vector& normal, RNArray<R3MeshIntersection *>& hits,
<DT>    RNScalar min_distance_squared, RNScalar max_distance_squared, 
<DT>    int (*IsCompatible)(const R3Point&, const R3Vector&, R3Mesh *, R3MeshFace *, void *), void *compatible_data,
<DT>    R3MeshFace *face) const;
<DT>
</DL>
<DT> <H4> Internal visualization and debugging functions: </H4>
<DL>
<DT>  void Outline(R3MeshSearchTreeNode *node, const R3Box& node_box) const;
<DT>  int Print(R3MeshSearchTreeNode *node, int depth) const;
<DT>
</DL>
<DT> <H4> Internal utility functions: </H4>
<DL>
<DT>  RNScalar DistanceSquared(const R3Point& query, const R3Box& box, RNScalar max_distance_squared) const;
<DT>  RNScalar DistanceSquared(const R3Point& query, const R3Point& point) const;
<DT>
</DL>
<DT> <H4> Internal data: </H4>
<DL>
<DT>  R3Mesh *mesh;
<DT>  R3MeshSearchTreeNode *root;
<DT>  int nnodes;
<DT>  RNMark mark;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Plane" HREF="../pkgs/R3Shapes/R3Plane.h">R3Plane</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Plane(void);
<DT>	R3Plane(const R3Plane& plane);
<DT>	R3Plane(RNScalar a, RNScalar b, RNScalar c, RNScalar d);
<DT>	R3Plane(const RNScalar array[4]);
<DT>	R3Plane(const R3Vector& normal, RNScalar d);
<DT>	R3Plane(const R3Point& point, const R3Vector& normal);
<DT>	R3Plane(const R3Point& point, const R3Line& line);
<DT>	R3Plane(const R3Point& point, const R3Vector& vector1, const R3Vector& vector2);
<DT>	R3Plane(const R3Point& point1, const R3Point& point2, const R3Point& point3);
<DT>	R3Plane(const RNArray<R3Point *>& points);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const RNScalar A(void) const;
<DT>	const RNScalar B(void) const;
<DT>	const RNScalar C(void) const;
<DT>	const RNScalar D(void) const;
<DT>	const RNScalar operator[](int i) const;
<DT>	const R3Point Point(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean operator==(const R3Plane& plane) const;
<DT>	const RNBoolean operator!=(const R3Plane& plane) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Mirror(const R3Plane& plane);
<DT>	void Translate(const R3Vector& vector);
<DT>	void Reposition(const R3Point& point);
<DT>	void Align(const R3Vector& normal);
<DT>        void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(const R3Point& point, const R3Vector& normal);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Plane operator-(void) const;
<DT>	
</DL>
<DT> <H4> Undocumented functions/operators: </H4>
<DL>
<DT>  	RNScalar& operator[](int i);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Point" HREF="../pkgs/R3Shapes/R3Point.h">R3Point</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor/destructor functions: </H4>
<DL>
<DT>	R3Point(void);
<DT>	R3Point(const R3Point& point);
<DT>	R3Point(RNCoord x, RNCoord y, RNCoord z);
<DT>	R3Point(const RNCoord array[3]);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const RNCoord X(void) const;
<DT>	const RNCoord Y(void) const;
<DT>	const RNCoord Z(void) const;
<DT>	const RNCoord Coord(RNDimension dim) const;
<DT>	const RNCoord operator[](RNDimension dim) const;
<DT>	const RNCoord *Coords(void) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>	const R3Vector Vector(void) const;
<DT>	const R3Box BBox(void) const;
<DT>	const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	const RNBoolean Collinear(const R3Point& point1, const R3Point& point2) const;
<DT>	const RNBoolean operator==(const R3Point& point) const;
<DT>	const RNBoolean operator!=(const R3Point& point) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void X(RNCoord x);
<DT>	void Y(RNCoord y);
<DT>	void Z(RNCoord z);
<DT>	void SetCoord(RNDimension dim, RNCoord coord);
<DT>        void Translate(const R3Vector& vector);
<DT>	void Project(const R3Line& line);
<DT>	void Project(const R3Plane& plane);
<DT>	void Mirror(const R3Plane& plane);
<DT>	void Rotate(const R3Vector& axis, RNAngle theta);
<DT>	void Rotate(const R3Line& axis, RNAngle theta);
<DT>	void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(RNCoord x, RNCoord y, RNCoord z);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Assignment operators: </H4>
<DL>
<DT>	R3Point& operator=(const R3Point& point);
<DT>	R3Point& operator+=(const R3Point& point);
<DT>	R3Point& operator+=(const R3Vector& vector);
<DT>	R3Point& operator-=(const R3Vector& vector);
<DT>	R3Point& operator*=(const RNScalar a);
<DT>	R3Point& operator/=(const RNScalar a);
<DT>
</DL>
<DT> <H4> Arithmetic operators: </H4>
<DL>
<DT>	friend R3Point operator-(const R3Point& point);
<DT>	friend R3Point operator+(const R3Point& point1, const R3Point& point2);
<DT>	friend R3Point operator+(const R3Point& point, const R3Vector& vector);
<DT>	friend R3Point operator+(const R3Vector& vector, const R3Point& point);
<DT>	friend R3Vector operator-(const R3Point& point1, const R3Point& point2);
<DT>	friend R3Point operator-(const R3Point& point, const R3Vector& vector);
<DT>	friend R3Point operator*(const R3Point& point, const RNScalar a);
<DT>	friend R3Point operator*(const RNScalar a, const R3Point& point);
<DT>	friend R3Point operator/(const R3Point& point, const RNScalar a);
<DT>
</DL>
<DT> <H4> Undocumented functions/operators: </H4>
<DL>
<DT>  	RNCoord& operator[](RNDimension dim);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Ray" HREF="../pkgs/R3Shapes/R3Ray.h">R3Ray</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Ray(void);
<DT>	R3Ray(const R3Ray& ray);
<DT>	R3Ray(const R3Point& point, const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>	R3Ray(const R3Point& point1, const R3Point& point2);
<DT>	R3Ray(RNCoord x1, RNCoord y1, RNCoord z1, RNCoord x2, RNCoord y2, RNCoord z2);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>        const R3Point& Start(void) const;
<DT>        const R3Vector& Vector(void) const;
<DT>        const R3Line& Line(void) const;
<DT>	const R3Point Point(RNScalar t) const;
<DT>	const RNScalar T(const R3Point& point) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean operator==(const R3Ray& ray) const;
<DT>	const RNBoolean operator!=(const R3Ray& ray) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Mirror(const R3Plane& plane);
<DT>        void Translate(const R3Vector& vector);
<DT>        void Reposition(const R3Point& point);
<DT>        void Align(const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>        void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(const R3Point& point, const R3Vector& vector, RNBoolean normalized = FALSE);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Ray operator-(void) const;
<DT>	
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Shape" HREF="../pkgs/R3Shapes/R3Shape.h">R3Shape</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors/destructors: </H4>
<DL>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Solid" HREF="../pkgs/R3Shapes/R3Solid.h">R3Solid</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Shape">R3Shape</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors/destructors ???: </H4>
<DL>
<DT>	R3Solid(void);
<DT>	~R3Solid(void);
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	const RNBoolean IsSolid(void) const;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Span" HREF="../pkgs/R3Shapes/R3Span.h">R3Span</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Span(void);
<DT>	R3Span(const R3Span& span);
<DT>	R3Span(const R3Point& point, const R3Vector& vector);
<DT>	R3Span(const R3Point& point1, const R3Point& point2);
<DT>	R3Span(RNCoord x1, RNCoord y1, RNCoord z1, RNCoord x2, RNCoord y2, RNCoord z2);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>        const R3Point& Start(void) const;
<DT>        const R3Point& End(void) const;
<DT>        const R3Vector& Vector(void) const;
<DT>        const R3Point Point(int k) const;
<DT>	const R3Point Point(RNScalar t) const;
<DT>        const R3Point& operator[](int k) const;
<DT>        const R3Ray& Ray(void) const;
<DT>        const R3Line& Line(void) const;
<DT>        const R3Point Midpoint(void) const;
<DT>        const R3Point Centroid(void) const;
<DT>        const R3Box BBox(void) const;
<DT>        const R3Sphere BSphere(void) const;
<DT>        const RNLength Length(void) const;
<DT>	const RNScalar T(const R3Point& point) const;
<DT>        const RNBoolean IsPoint(void) const;
<DT>	const RNBoolean operator==(const R3Span& span) const;
<DT>	const RNBoolean operator!=(const R3Span& span) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Mirror(const R3Plane& plane);
<DT>        void Translate(const R3Vector& vector);
<DT>        void Reposition(int k, const R3Point& point);
<DT>        void Align(const R3Vector& vector);
<DT>        void Transform(const R3Transformation& transformation);
<DT>        void InverseTransform(const R3Transformation& transformation);
<DT>        void Reset(const R3Point& point1, const R3Point& point2);
<DT>	RNClassID Clip(const R3Plane& plane);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Span operator-(void) const;
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Sphere" HREF="../pkgs/R3Shapes/R3Sphere.h">R3Sphere</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Solid">R3Solid</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Sphere(void);
<DT>        R3Sphere(const R3Sphere& sphere);
<DT>        R3Sphere(const R3Point& center, RNLength radius);
<DT>
</DL>
<DT> <H4> Sphere property functions/operators: </H4>
<DL>
<DT>        const R3Point& Center(void) const;
<DT>        const RNLength Radius(void) const;
<DT>	const RNBoolean IsEmpty(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const ;
<DT>	virtual const RNBoolean IsPlanar(void) const ;
<DT>	virtual const RNBoolean IsConvex(void) const ;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>	virtual const RNArea Area(void) const;
<DT>	virtual const RNVolume Volume(void) const;
<DT>	virtual const R3Point Centroid(void) const;
<DT>	virtual const R3Shape& BShape(void) const;
<DT>	virtual const R3Box BBox(void) const;
<DT>	virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        virtual void Empty(void);
<DT>        virtual void Translate(const R3Vector& vector);
<DT>        virtual void Reposition(const R3Point& center);
<DT>        virtual void Resize(RNLength radius);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Sphere);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Sphere);
<DT>
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3SphericalGrid" HREF="../pkgs/R3Shapes/R3SphericalGrid.h">R3SphericalGrid</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors: </H4>
<DL>
<DT>  R3SphericalGrid(int phi_resolution = 0, int theta_resolution = 0, int radius_resolution = 0);
<DT>  R3SphericalGrid(const R3SphericalGrid& grid);
<DT>  ~R3SphericalGrid(void);
<DT>
</DL>
<DT> <H4> Grid property functions: </H4>
<DL>
<DT>  int NEntries(void) const;
<DT>  int PhiResolution(void) const;
<DT>  int ThetaResolution(void) const;
<DT>  int RadiusResolution(void) const;
<DT>  int Resolution(int dim) const;
<DT>  RNScalar Sum(void) const;
<DT>  RNScalar Maximum(void) const;
<DT>  RNScalar Minimum(void) const;
<DT>  RNInterval Range(void) const;
<DT>  RNScalar L1Norm(void) const;
<DT>  RNScalar L2Norm(void) const;
<DT>  RNScalar Volume(void) const;
<DT>  RNScalar Integral(RNScalar (*f)(RNScalar)) const;
<DT>  RNScalar Integral(const R3SphericalGrid& g, RNScalar (*f)(RNScalar, RNScalar)) const;
<DT>  int Cardinality(void) const;
<DT>  RNLength WorldRadius(void) const;
<DT>  R3Point WorldOrigin(void) const;
<DT>  R3Sphere WorldSphere(void) const;
<DT>
</DL>
<DT> <H4> Transformation property functions: </H4>
<DL>
<DT>  const R3Affine& WorldToGridTransformation(void) const;
<DT>  const R3Affine& GridToWorldTransformation(void) const;
<DT>  RNScalar WorldToGridScaleFactor(void) const;
<DT>  RNScalar GridToWorldScaleFactor(void) const;
<DT>
</DL>
<DT> <H4> Grid value access functions: </H4>
<DL>
<DT>  RNScalar GridValue(int i, int j, int k) const;
<DT>  RNScalar GridValue(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  RNScalar GridValue(const R3Point& grid_point) const;
<DT>  RNScalar WorldValue(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  RNScalar WorldValue(const R3Point& world_point) const;
<DT>  RNScalar& operator()(int i, int j,int k);
<DT>
</DL>
<DT> <H4> Grid manipulation functions: </H4>
<DL>
<DT>  void Abs(void);
<DT>  void Sqrt(void);
<DT>  void Square(void);
<DT>  void Negate(void);
<DT>  void Invert(void);
<DT>  void Normalize(void);
<DT>  void Clear(RNScalar value = 0);
<DT>  void Add(RNScalar value);
<DT>  void Add(const R3SphericalGrid& grid);
<DT>  void Subtract(RNScalar value);
<DT>  void Subtract(const R3SphericalGrid& grid);
<DT>  void Multiply(RNScalar value);
<DT>  void Multiply(const R3SphericalGrid& grid);
<DT>  void Divide(RNScalar value);
<DT>  void Divide(const R3SphericalGrid& grid);
<DT>  void Threshold(RNScalar threshold, RNScalar low, RNScalar high);
<DT>  void SetGridValue(int i, int j, int k, RNScalar value);
<DT>  void AddGridValue(int i, int j, int k, RNScalar value);
<DT>  void Add(const R3Grid& grid);
<DT>
</DL>
<DT> <H4> Arithmetic operators: </H4>
<DL>
<DT>  R3SphericalGrid& operator=(const R3SphericalGrid& grid);
<DT>  R3SphericalGrid& operator+=(RNScalar scale);
<DT>  R3SphericalGrid& operator+=(const R3SphericalGrid& grid);
<DT>  R3SphericalGrid& operator-=(RNScalar scale);
<DT>  R3SphericalGrid& operator-=(const R3SphericalGrid& grid);
<DT>  R3SphericalGrid& operator*=(RNScalar scale);
<DT>  R3SphericalGrid& operator*=(const R3SphericalGrid& grid);
<DT>  R3SphericalGrid& operator/=(RNScalar scale);
<DT>  R3SphericalGrid& operator/=(const R3SphericalGrid& grid);
<DT>
</DL>
<DT> <H4> Rasterization functions: </H4>
<DL>
<DT>  void RasterizeGridPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value);
<DT>  void RasterizeGridPoint(const R3Point& point, RNScalar value);
<DT>  void RasterizeWorldPoint(RNCoord x, RNCoord y, RNCoord z, RNScalar value);
<DT>  void RasterizeWorldPoint(const R3Point& point, RNScalar value);
<DT>
</DL>
<DT> <H4> Relationship functions: </H4>
<DL>
<DT>  RNScalar Dot(const R3SphericalGrid& grid) const;
<DT>  RNScalar L1Distance(const R3SphericalGrid& grid) const;
<DT>  RNScalar L2Distance(const R3SphericalGrid& grid) const;
<DT>  RNScalar L2DistanceSquared(const R3SphericalGrid& grid) const;
<DT>
</DL>
<DT> <H4> Transformation manipulation functions: </H4>
<DL>
<DT>  void SetWorldToGridTransformation(const R3Affine& affine);
<DT>  void SetWorldToGridTransformation(const R3Box& world_box);
<DT>  void SetWorldToGridTransformation(const R3Point& world_origin, const R3Vector& world_axis1, const R3Vector& world_axis2, RNLength world_radius);
<DT>
</DL>
<DT> <H4> Transformation utility functions: </H4>
<DL>
<DT>  R3Point GridPosition(const R3Point& world_point) const;
<DT>  R3Point GridPosition(RNCoord x, RNCoord y, RNCoord z) const;
<DT>  R3Point WorldPosition(const R3Point& grid_point) const;
<DT>  R3Point WorldPosition(RNCoord x, RNCoord y, RNCoord z) const;
<DT>
</DL>
<DT> <H4> I/O functions: </H4>
<DL>
<DT>  int ReadFile(const char *filename);
<DT>  int WriteFile(const char *filename) const;
<DT>  int Read(FILE *fp = NULL);
<DT>  int Write(FILE *fp = NULL) const;
<DT>  int Print(FILE *fp = NULL) const;
<DT>
</DL>
<DT> <H4> Debugging functions: </H4>
<DL>
<DT>  const RNScalar *GridValues(void) const;
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Surface" HREF="../pkgs/R3Shapes/R3Surface.h">R3Surface</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Shape">R3Shape</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors/destructors ???: </H4>
<DL>
<DT>	R3Surface(void);
<DT>	~R3Surface(void);
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	const RNBoolean IsSurface(void) const;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Triad" HREF="../pkgs/R3Shapes/R3Triad.h">R3Triad</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Triad(void);
<DT>	R3Triad(const R3Triad& triad);
<DT>	R3Triad(const R3Vector& xaxis, const R3Vector& yaxis, const R3Vector& zaxis);
<DT>	R3Triad(const R3Vector& towards, const R3Vector& up);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>        const R4Matrix Matrix(void) const;
<DT>        const R4Matrix InverseMatrix(void) const;
<DT>	const R3Vector& Axis(RNDimension dim) const;
<DT>	const R3Vector& operator[](RNDimension dim) const;
<DT>	const RNBoolean operator==(const R3Triad& triad) const;
<DT>	const RNBoolean operator!=(const R3Triad& triad) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        void Normalize(void);
<DT>	void Rotate(RNAxis axis, RNAngle radians);
<DT>	void Rotate(const R3Vector& vector, RNAngle radians);
<DT>	void Rotate(const R3Vector& from, const R3Vector& to);
<DT>	void Mirror(const R3Plane& plane);
<DT>        void Transform(const R3Transformation& transformation);
<DT>        void InverseTransform(const R3Transformation& transformation);
<DT>	R3Triad& operator=(const R3Triad& triad);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>        void Outline(void) const;
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3TriangleArray" HREF="../pkgs/R3Shapes/R3TriangleArray.h">R3TriangleArray</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Surface">R3Surface</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>        R3TriangleArray(void);
<DT>        R3TriangleArray(const R3TriangleArray& array);
<DT>        R3TriangleArray(const RNArray<R3TriangleVertex *>& vertices, const RNArray<R3Triangle *>& triangles);
<DT>
</DL>
<DT> <H4> Triangle array properties: </H4>
<DL>
<DT>        const R3Box& Box(void) const;
<DT>
</DL>
<DT> <H4> Vertex access functions/operators: </H4>
<DL>
<DT>        int NVertices(void) const;
<DT>	R3TriangleVertex *Vertex(int index) const;
<DT>
</DL>
<DT> <H4> Triangle access functions/operators: </H4>
<DL>
<DT>        int NTriangles(void) const;
<DT>	R3Triangle *Triangle(int index) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>        virtual const RNLength Length(void) const;
<DT>        virtual const RNArea Area(void) const;
<DT>        virtual const R3Point Centroid(void) const;
<DT>        virtual const R3Shape& BShape(void) const;
<DT>        virtual const R3Box BBox(void) const;
<DT>        virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	virtual void Flip(void);
<DT>	virtual void Mirror(const R3Plane& plane);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>	virtual void MoveVertex(R3TriangleVertex *vertex, const R3Point& position);
<DT>	virtual void Update(void);  
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3TriangleArray);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3TriangleArray);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3TriangleVertex" HREF="../pkgs/R3Shapes/R3TriangleVertex.h">R3TriangleVertex</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>	None
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructors: </H4>
<DL>
<DT>	R3TriangleVertex(void);
<DT>        R3TriangleVertex(const R3TriangleVertex& vertex);
<DT>        R3TriangleVertex(const R3Point& position);
<DT>        R3TriangleVertex(const R3Point& position, const R3Vector& normal);
<DT>        R3TriangleVertex(const R3Point& position, const R2Point& texcoords);
<DT>        R3TriangleVertex(const R3Point& position, const R3Vector& normal, const R2Point& texcoords);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const R3Point& Position(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>	const R2Point& TextureCoords(void) const;
<DT>        const RNFlags Flags(void) const;
<DT>        const RNMark Mark(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>        void Mirror(const R3Plane& plane);
<DT>        void Transform(const R3Transformation& transformation);
<DT>	void SetPosition(const R3Point& position);
<DT>	void SetNormal(const R3Vector& normal);
<DT>	void SetTextureCoords(const R2Point& texcoords);
<DT>        void SetMark(RNMark mark);
<DT>
<DT>        R3Point position;
<DT>	R3Vector normal;
<DT>	R2Point texcoords;
<DT>        RNFlags flags;
<DT>        RNMark mark;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Triangle" HREF="../pkgs/R3Shapes/R3Triangle.h">R3Triangle</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Surface">R3Surface</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>        R3Triangle(void);
<DT>        R3Triangle(const R3Triangle& triangle);
<DT>        R3Triangle(R3TriangleVertex *v0, R3TriangleVertex *v1, R3TriangleVertex *v2);
<DT>        R3Triangle(R3TriangleVertex *vertices[3]);
<DT>
</DL>
<DT> <H4> Vertex access functions/operators: </H4>
<DL>
<DT>	R3TriangleVertex *Vertex(int index) const;
<DT>	R3TriangleVertex *V0(void) const;
<DT>	R3TriangleVertex *V1(void) const;
<DT>	R3TriangleVertex *V2(void) const;
<DT>
</DL>
<DT> <H4> Triangle property functions/operators: </H4>
<DL>
<DT>	const R3Plane& Plane(void) const;
<DT>	const R3Vector& Normal(void) const;
<DT>        const R3Box& Box(void) const;
<DT>        const RNFlags Flags(void) const;
<DT>        const RNMark Mark(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>	const RNBoolean IsDegenerate(void) const;
<DT>
</DL>
<DT> <H4> Shape property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsPoint(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsPlanar(void) const;
<DT>	virtual const RNBoolean IsConvex(void) const;
<DT>        virtual const RNInterval NFacets(void) const;
<DT>        virtual const RNLength Length(void) const;
<DT>        virtual const RNArea Area(void) const;
<DT>        virtual const R3Point Centroid(void) const;
<DT>        virtual const R3Shape& BShape(void) const;
<DT>        virtual const R3Box BBox(void) const;
<DT>        virtual const R3Sphere BSphere(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	virtual void Flip(void);
<DT>	virtual void Transform(const R3Transformation& transformation);
<DT>	virtual void Mirror(const R3Plane& plane);
<DT>	virtual void Reset(R3TriangleVertex *v1, R3TriangleVertex *v2, R3TriangleVertex *v3);
<DT>	virtual void Reset(R3TriangleVertex *vertices[3]);
<DT>        virtual void SetMark(RNMark mark);
<DT>	virtual void Update(void);  
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Draw(const R3DrawFlags draw_flags = R3_DEFAULT_DRAW_FLAGS) const;
<DT>
</DL>
<DT> <H4> Arithmetic functions/operators: </H4>
<DL>
<DT>	R3Triangle operator-(void) const;
<DT>	
</DL>
<DT> <H4> Standard shape definitions: </H4>
<DL>
<DT>	RN_CLASS_TYPE_DECLARATIONS(R3Triangle);
<DT>        R3_SHAPE_RELATIONSHIP_DECLARATIONS(R3Triangle);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Vector" HREF="../pkgs/R3Shapes/R3Vector.h">R3Vector</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R3Vector(void);
<DT>        R3Vector(const R3Vector& vector);
<DT>	R3Vector(RNCoord x, RNCoord y, RNCoord z);
<DT>	R3Vector(const RNCoord array[3]);
<DT>	R3Vector(RNAngle pitch, RNAngle yaw);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const RNCoord X(void) const;
<DT>	const RNCoord Y(void) const;
<DT>	const RNCoord Z(void) const;
<DT>	const RNCoord Coord(RNDimension dim) const;
<DT>	const RNCoord operator[](RNDimension dim) const;
<DT>	const RNCoord *Coords(void) const;
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean IsFinite(void) const;
<DT>	const RNBoolean IsNormalized(void) const;
<DT>	const RNLength Length(void) const;
<DT>	const R3Point Point(void) const;
<DT>	const RNSextant Sextant(void) const;
<DT>	const RNOctant Octant(void) const;
<DT>	const RNDimension MinDimension(void) const;
<DT>	const RNDimension MaxDimension(void) const;
<DT>
</DL>
<DT> <H4> Relationship functions/operators: </H4>
<DL>
<DT>	const RNBoolean operator==(const R3Vector& vector) const;
<DT>	const RNBoolean operator!=(const R3Vector& vector) const;
<DT>	const RNScalar Dot(const R3Vector& vector) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void X(RNCoord x);
<DT>	void Y(RNCoord y);
<DT>	void Z(RNCoord z);
<DT>	void SetCoord(RNDimension dim, RNCoord coord);
<DT>	void Flip(void);
<DT>	void Normalize(void);
<DT>	void Cross(const R3Vector& vector);
<DT>	void Rotate(const R3Vector& axis, RNAngle theta);
<DT>	void Project(const R3Vector& vector);
<DT>	void Project(const R3Plane& plane);
<DT>	void Mirror(const R3Plane& plane);
<DT>	void Transform(const R3Transformation& transformation);
<DT>	void InverseTransform(const R3Transformation& transformation);
<DT>	void Reset(RNCoord x, RNCoord y, RNCoord z);
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Draw(void) const;
<DT>        void Outline(void) const;
<DT>
</DL>
<DT> <H4> Assignment operators: </H4>
<DL>
<DT>	R3Vector& operator=(const R3Vector& vector);
<DT>	R3Vector& operator+=(const R3Vector& vector);
<DT>	R3Vector& operator-=(const R3Vector& vector);
<DT>	R3Vector& operator*=(const RNScalar a);
<DT>        R3Vector& operator*=(const R3Vector& vector);
<DT>	R3Vector& operator/=(const RNScalar a);
<DT>	R3Vector& operator/=(const R3Vector& vector);
<DT>
</DL>
<DT> <H4> Arithmetic operators: </H4>
<DL>
<DT>	friend R3Vector operator+(const R3Vector& vector);
<DT>	friend R3Vector operator-(const R3Vector& vector);
<DT>	friend R3Vector operator+(const R3Vector& vector1, const R3Vector& vector2);
<DT>	friend R3Vector operator-(const R3Vector& vector1, const R3Vector& vector2);
<DT>	friend R3Vector operator*(const R3Vector& vector1, const R3Vector& vector2);
<DT>	friend R3Vector operator*(const R3Vector& vector, const RNScalar a);
<DT>	friend R3Vector operator*(const RNScalar a, const R3Vector& vector);
<DT>	friend R3Vector operator/(const R3Vector& vector1, const R3Vector& vector2);
<DT>	friend R3Vector operator/(const R3Vector& vector, const RNScalar a);
<DT>	friend R3Vector operator%(const R3Vector& vector1, const R3Vector& vector2);
<DT>
</DL>
<DT> <H4> Undocumented functions/operators: </H4>
<DL>
<DT>  	RNCoord& operator[](RNDimension dim);
<DT>
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R3Transformation" HREF="../pkgs/R3Shapes/R3Transformation.h">R3Transformation</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Destructor function: </H4>
<DL>
<DT>        virtual ~R3Transformation(void);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	virtual const RNBoolean IsMirrored(void) const;
<DT>	virtual const RNBoolean IsLinear(void) const;
<DT>	virtual const RNBoolean IsAffine(void) const;
<DT>	virtual const RNBoolean IsIsotropic(void) const;
<DT>
</DL>
<DT> <H4> Application functions/operators: </H4>
<DL>
<DT>	virtual void Apply(R3Vector& vector) const = 0;
<DT>	virtual void Apply(R3Point& point) const = 0;
<DT>	virtual void Apply(R3Transformation& transformation) const = 0;
<DT>	virtual void Apply(R3Affine& affine) const = 0;
<DT>	virtual void ApplyInverse(R3Vector& vector) const = 0;
<DT>	virtual void ApplyInverse(R3Point& point) const = 0;
<DT>	virtual void ApplyInverse(R3Transformation& transformation) const = 0;
<DT>	virtual void ApplyInverse(R3Affine& affine) const = 0;
<DT>	virtual void ApplyInverseTranspose(R3Vector& vector) const = 0;
<DT>	virtual void ApplyTranspose(R3Vector& vector) const = 0;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	virtual void Reset(const R3Transformation& transformation) = 0;
<DT>	virtual void Transform(const R3Transformation& transformation) = 0;
<DT>	virtual void InverseTransform(const R3Transformation& transformation) = 0;
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        virtual void Load(void) const = 0;
<DT>        virtual void Draw(void) const = 0;
<DT>        virtual void Push(void) const = 0;
<DT>        virtual void Pop(void) const = 0;
<DT>
</DL>
<DT> <H4> Do not use these ???: </H4>
<DL>
<DT>	virtual const RNScalar ScaleFactor(void) const;
</DL>
</DL> </DL>
</DL>



<P>
<HR> <H2> <A NAME="R4Matrix" HREF="../pkgs/R3Shapes/R4Matrix.h">R4Matrix</A> </H2> 

<DL> <DL>
<DT> <H3>Base Classes:</H3> 
<DL>
<DT> <H4>Public Base Classes:</H4> 
<DL>
<DT>    <A HREF="#R3Base">R3Base</A>
</DL> </DL>
<P>
<DT> <H3>Member Functions:</H3>
<DL>
<DT> <H4> Constructor functions: </H4>
<DL>
<DT>	R4Matrix(void);
<DT>        R4Matrix(const R4Matrix& matrix);
<DT>	R4Matrix(RNScalar a00, RNScalar a01, RNScalar a02, RNScalar a03,
<DT>   	         RNScalar a10, RNScalar a11, RNScalar a12, RNScalar a13,
<DT>                 RNScalar a20, RNScalar a21, RNScalar a22, RNScalar a23,
<DT>                 RNScalar a30, RNScalar a31, RNScalar a32, RNScalar a33);
<DT>	R4Matrix(const RNScalar* array);
<DT>
</DL>
<DT> <H4> Property functions/operators: </H4>
<DL>
<DT>	const RNBoolean IsZero(void) const;
<DT>	const RNBoolean IsIdentity(void) const;
<DT>        const RNBoolean IsIsotropic(void) const;
<DT>        const RNBoolean HasTranslation(void) const;
<DT>        const RNBoolean HasScale(void) const;
<DT>        const RNBoolean HasRotation(void) const;
<DT>        const RNBoolean HasMirror(void) const;
<DT>  	const RNScalar *operator[](int i) const;
<DT>        const RNScalar Determinant(void) const;
<DT>	const R4Matrix Transpose(void) const;
<DT>	const R4Matrix Inverse(void) const;
<DT>	const RNBoolean operator==(const R4Matrix& matrix) const;
<DT>	const RNBoolean operator!=(const R4Matrix& matrix) const;
<DT>
</DL>
<DT> <H4> Draw functions/operators: </H4>
<DL>
<DT>        void Load(void) const;
<DT>        void Draw(void) const;
<DT>        void Push(void) const;
<DT>        void Pop(void) const;
<DT>
</DL>
<DT> <H4> Manipulation functions/operators: </H4>
<DL>
<DT>	void Flip(void);
<DT>	void Invert(void);
<DT>	void XTranslate(RNScalar offset);
<DT>	void YTranslate(RNScalar offset);
<DT>	void ZTranslate(RNScalar offset);
<DT>	void Translate(RNScalar offset);
<DT>	void Translate(RNAxis axis, RNScalar offset);
<DT>	void Translate(const R3Vector& offset);
<DT>	void XScale(RNScalar scale);
<DT>	void YScale(RNScalar scale);
<DT>	void ZScale(RNScalar scale);
<DT>	void Scale(RNScalar scale);
<DT>	void Scale(RNAxis axis, RNScalar scale);
<DT>	void Scale(const R3Vector& scale);
<DT>	void XRotate(RNAngle radians);
<DT>	void YRotate(RNAngle radians);
<DT>	void ZRotate(RNAngle radians);
<DT>	void Rotate(const R3Vector& radians);
<DT>	void Rotate(RNAxis axis, RNAngle radians);
<DT>	void Rotate(const R3Vector& vector, RNAngle radians);
<DT>	void Rotate(const R3Vector& from, const R3Vector& to);
<DT>	void Transform(const R4Matrix& matrix);
<DT>	void Multiply(const R4Matrix& matrix);
<DT>	void Add(const R4Matrix& matrix);
<DT>	void Subtract(const R4Matrix& matrix);
<DT>
</DL>
<DT> <H4> Assignment operators: </H4>
<DL>
<DT>	R4Matrix& operator=(const R4Matrix& matrix);
<DT>	R4Matrix& operator+=(const R4Matrix& matrix);
<DT>	R4Matrix& operator-=(const R4Matrix& matrix);
<DT>	R4Matrix& operator*=(RNScalar a);
<DT>	R4Matrix& operator*=(const R4Matrix& matrix);
<DT>	R4Matrix& operator/=(RNScalar a);
<DT>
</DL>
<DT> <H4> Arithmetic operators: </H4>
<DL>
<DT>	friend R4Matrix operator-(const R4Matrix& matrix);
<DT>	friend R4Matrix operator+(const R4Matrix& matrix1, const R4Matrix& matrix2);
<DT>	friend R4Matrix operator-(const R4Matrix& matrix1, const R4Matrix& matrix2);
<DT>	friend R4Matrix operator*(RNScalar a, const R4Matrix& matrix);
<DT>	friend R4Matrix operator*(const R4Matrix& matrix, RNScalar a);
<DT>	friend R4Matrix operator*(const R4Matrix& matrix1, const R4Matrix& matrix2);
<DT>	friend R4Matrix operator/(const R4Matrix& matrix, RNScalar scale);
<DT>	friend R3Vector operator*(const R4Matrix& matrix, const R3Vector& vector);
<DT>	friend R3Point operator*(const R4Matrix& matrix, const R3Point& point);
<DT>
</DL>
<DT> <H4> Undocumented functions/operators: </H4>
<DL>
<DT>  	RNScalar *operator[](int i);
<DT>
</DL>
</DL> </DL>
</DL>



<P>



<HR>
Click <A HREF="pkgs.html">this</A> to go back to list of GAPS packages.
<P>
</BODY>
<ADDRESS>funk@cs.princeton.edu</ADDRESS>

</HTML>



